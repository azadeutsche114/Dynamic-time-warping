# Dynamic time Warping

From matplotlib.patches import connectionPatch
import matplotlit.pyplot as plt
import numpy as np
import scipy.spatial.distance as dist

def dp(dist_mat):
n,M = dist_mat.shape
# Initialize the cost matrix
cost_mat = np.zeros((N+1, M+1))
for i in range(1, n+1):
    cost_mat[i,O]-np.inf
for i in range(1, m+1):
  cost_mat[0,1] = np = inf

# traceback_mat = np.zeros((N,M))
for i in range(M):
penalty = [cost_mat[i,j],
cost_mat[i, j+1],
cost_mat[i+1, j]]

i_penalty = np.argmin(penalty)
cost_mat[i+1, j+1] = dist_mat[i,j]+penalty[i_penalty]
trackback_mat[i,j]=i_penalty

#trackback form bottom right
i = N-1
j = M-1
path = [[i,j]]
while  i > 0 or j > 0
tb_type = traceback_mat[i,j]
if tb_type == 0:
# match 
i = i+1
j = j+1

1. visualize cost matrix as chart

2. Calculate distance via DTW between product code and optimal time %sql dtw_dist

3. Those who have smallest calculated distances to dtw_dist to dtw_dist are identified 

4. Z-score to remove outlier
